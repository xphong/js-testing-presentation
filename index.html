<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JS Testing</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<link rel="stylesheet" href="lib/css/main.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>JS Testing</h2>
				</section>

				<section>
					<h3>Agenda</h3>
					<ol>
            <li>Test Driven Development</li>
            <li>Old Solutions to New Testing Problems</li>
					</ol>
				</section>

				<section>
					<h3>Test Driven Development</h3>
					<div>
						<ul>
							<li>Writing tests before you write the code that passes them</li>
							<li>Forces you to think about implementation</li>
							<li>Makes debugging easier/Refactor with confidence</li>
							<li>Immediate test coverage</li>
						</ul>
					</div>

					<aside class="notes">
						<p>
						</p>
					</aside>
				</section>

				<section>
						<h3>Red, Green, Refactor</h3>
						<div>
							<img src="images/tdd.png" height="200" />
							<ol>
								<li>Add a test</li>
								<li>Run all tests and see if the new one fails</li>
								<li>Write some code</li>
								<li>Run tests</li>
								<li>Refactor code</li>
								<li>Repeat</li>
							</ol>
						</div>

						<aside class="notes">
							<p>
									<br>1. Before you write implementation code, write some code that proves that the implementation works or fails. Watch the test fail before moving to the next step (this is how we know that a passing test is not a false positive — how we test our tests).
									<br>2. Write the implementation code and watch the test pass.
									<br>3. Refactor if needed. You should feel confident refactoring your code now that you have a test to tell you if you’ve broken something.
							</p>
						</aside>
					</section>

				<section>
					<h3>Red</h3>
					<div>
						<pre><code data-trim>
describe('fib tests', () => {
  it('should return `[0, 1, 1, 2]` with the number being 4', () => {
    const expectedResult = [0, 1, 1, 2]
    expect(fib(4)).toEqual(expectedResult);
  });
});
					</code></pre>
					</div>

					<aside class="notes">
						<p>
						</p>
					</aside>
        </section>


				<section>
					<h3>Green</h3>
					<div>
						<pre><code data-trim>
export const fib = (num) => {
  let a = 1, b = 0, temp;

  while (num >= 0){
    temp = a;
    a = a + b;
    b = temp;
    num--;
  }

  return b;
};
					</code></pre>
					</div>

					<aside class="notes">
						<p>
						</p>
					</aside>
        </section>

        <section>
					<h3>Refactor</h3>
					<div>
						<pre><code data-trim>
export const fib = (num) => {
  if (num < 2){
    return num
  }
  return fib(num - 1) + fib(num - 2);
};
					</code></pre>
					</div>

					<aside class="notes">
						<p>
						</p>
					</aside>
        </section>

        <section>
					<h3>Old Solutions to New Testing Problems</h3>
					<div>
            <p>
              JavaScript test tooling has improved a lot. The problem now:
              Test Maintainability. How can we learn how
              to write more
              maintainable tests?
            </p>
					</div>

					<aside class="notes">
						<p>
              5 Patterns
            </p>
            <p>
                Takeaways
                1. New testing approaches
                2. Clearer explanation of the benefits
                3. Shared language and support
            </p>
					</aside>
        </section>

        <section>
          <h3>Flexible Tests</h3>
					<div>
						<pre><code data-trim>
import formatAddress from '../formatAddress';
import addresses from '../__sampleData__/addresses';

describe('formatAddress', () => {
  it('formats addresses correctly', () => {
    let expectedResult;
    for (const address of addresses) {
      if (address.street2) {
        expectedResult = `${address.street1}
        ${address.street2}
        ${address.city}, ${address.province} ${address.postalCode}`;
      } else {
        expectedResult = `${address.street1}
        ${address.city}, ${address.province} ${address.postalCode}`;
      }
      expect(formatAddress(address)).toEqual(expectedResult);
    }
  });
});
					</code></pre>
					</div>

					<aside class="notes">
            <p>"Using conditional logic to reuse a single test to verify several different
                cases."</p>
						<p>
                - Tests can be hard to understand
                - Tests might have a bug, and you don't test your tests
                - If test data changes, not all cases might be executed
            </p>
					</aside>
        </section>

        <section>
            <h3>Solution: Simple Tests</h3>
            <div>
              <pre><code data-trim>
it('formats an address with two lines correctly', () => {
  const address = addresses[0];
  const expectedResult = `${address.street1}
  ${address.street2}
  ${address.city}, ${address.province} ${address.postalCode}`;
  expect(formatAddress(address)).toEqual(expectedResult);
});
            </code></pre>
            </div>

            <div>
                <pre><code data-trim>
it('formats an address with one line correctly', () => {
  const address = addresses[1];
  const expectedResult = `${address.street1}
  ${address.city}, ${address.province} ${address.postalCode}`;
  expect(formatAddress(address)).toEqual(expectedResult);
});
              </code></pre>
              </div>

            <aside class="notes">
                <p>
                    Split the tests into simpler cases, controlling for specific situations.
                </p>
            </aside>
          </section>

        <section>
          <h3>Mystery Guest</h3>
					<div>
						<pre><code data-trim>
import formatAddress from '../formatAddress';
import addresses from '../__sampleData__/addresses';

describe('formatAddress', () => {
  it('formats an address with one line correctly', () => {
    const address = addresses[1];
    const expectedResult = `${address.street1}
    ${address.city}, ${address.province} ${address.postalCode}`;
    expect(formatAddress(address)).toEqual(expectedResult);
  });
});
					</code></pre>
          </div>

          <aside class="notes">
            <p>
                "The test reader is not able to see the cause and effect between
                fixture and verification logic because part of it is done outside the
                Test Method.""
            </p>
                <p>- Can't see the data relevant to what's being tested, have to look in
                another file</p>
                <p>- Test harder to understand, easier for bugs to sneak through</p>
                <p>- Coupled to shared test data; if it changes, test could break or give a
                false positive</p>
            </aside>
          </section>

          <section>
              <h3>Solution: set up the data closer to the test</h3>
              <div>
                <pre><code data-trim>
it('formats an address with one line correctly', () => {
  const address = {
    street1: '101 College Street',
    city: 'Toronto',
    province: 'ON',
    postalCode: 'M5G 1L7'
  };
  const expectedResult = `${address.street1}
  ${address.city}, ${address.province} ${address.postalCode}`;
  expect(formatAddress(address)).toEqual(expectedResult);
});
              </code></pre>
              </div>

              <aside class="notes">
                  <p>
                      Approach 1: inline set up
                  </p>
                  <p>“Each Test Method creates its own Fresh Fixture by [building] exactly
                      the test fixture it requires.”</p>
              </aside>
            </section>

            <section>
                <h3>Approach 2: delegated set up</h3>
                <div>
                  <pre><code data-trim>
function createAddress({ hasStreet2 = false }) {
  const address = {
    street1: '101 College Street',
    city: 'Toronto',
    province: 'ON',
    postalCode: 'M5G 1L7'
  };
  if (hasStreet2) {
    address.street2 = 'Suite 123';
  }
  return address;
};
                </code></pre>
                </div>

                <div>
                    <pre><code data-trim>
it('formats an address with one line correctly', () => {
  const address = createAddress({ hasStreet2: false });
  const expectedResult = `${address.street1}
  ${address.city}, ${address.province} ${address.postalCode}`;
  expect(formatAddress(address)).toEqual(expectedResult);
});
                  </code></pre>
                  </div>

                <aside class="notes">
                    <p>"Each Test Method creates its own Fresh Fixture by calling Creation
                        Methods from within the Test Methods."</p>
                </aside>
              </section>

              <section>
                  <h3>Approach 3: implicit set up</h3>
                  <div>
                    <pre><code data-trim>
let address;
beforeEach(() => {
  address = {
    street1: '101 College Street',
    city: 'Toronto',
    province: 'ON',
    postalCode: 'M5G 1L7'
  };
});
                  </code></pre>
                  </div>

                  <div>
                      <pre><code data-trim>
it('formats an address with two lines correctly', () => {
  address.street2 = 'Apt. 317';
  const expectedResult = `${address.street1}
  ${address.street2}
  ${address.city}, ${address.province} ${address.postalCode}`;
  expect(formatAddress(address)).toEqual(expectedResult);
});
                    </code></pre>
                    </div>

                  <aside class="notes">
                      <p>“We build the test fixture common to several tests in the setUp
                          method."</p>
                  </aside>
                </section>




          <section>
              <div>
                  <img src="images/pyramid.png" height="500" />
                </div>

                <aside class="notes">
                  <p></p>
                </aside>
          </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
